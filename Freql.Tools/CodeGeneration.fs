namespace Freql.Tools

open System
open System
open System.IO
open System.Text.Json
open System.Text.Json.Serialization

module CodeGeneration =

    module Header =

        let lines =
            [ "//----------------------------------------------------------------------------------- "
              "// <auto-generated>                                                                   "
              "//     This code was generated via Freql.Tools (https://github.com/mc738/Freql).      "
              "//                                                                                    "
              "//     Manual changes to this file may cause unexpected behavior in your application. "
              "//     Manual changes to this file will be overwritten if the code is regenerated.    "
              "// </auto-generated>                                                                  "
              "//----------------------------------------------------------------------------------- " ]

    module Configuration =

        type DatabaseConfiguration =
            { [<JsonPropertyName("name")>]
              Name: string
              [<JsonPropertyName("type")>]
              Type: string
              [<JsonPropertyName("connectionString")>]
              ConnectionString: string
              [<JsonPropertyName("generatorProfiles")>]
              GeneratorProfiles: GeneratorProfile seq }

            static member TryLoad(path: string) =
                try
                    File.ReadAllText path
                    |> JsonSerializer.Deserialize<DatabaseConfiguration seq>
                    |> Ok
                with exn ->
                    Error exn.Message

        and GeneratorProfile =
            { [<JsonPropertyName("name")>]
              Name: string
              [<JsonPropertyName("outputPath")>]
              OutputPath: string
              [<JsonPropertyName("namespace")>]
              Namespace: string
              [<JsonPropertyName("moduleName")>]
              ModuleName: string
              [<JsonPropertyName("includeJsonAttributes")>]
              IncludeJsonAttributes: bool
              [<JsonPropertyName("nameSuffix")>]
              NameSuffix: string
              [<JsonPropertyName("typeReplacements")>]
              TypeReplacements: TypeReplacementConfiguration seq
              [<JsonPropertyName("tableNameReplacements")>]
              TableNameReplacements: TableNameReplacement seq }

        and TypeReplacementConfiguration =
            { [<JsonPropertyName("matchValue")>]
              MatchValue: string
              [<JsonPropertyName("matchType")>]
              MatchType: string
              [<JsonPropertyName("replacementValue")>]
              ReplacementValue: string
              [<JsonPropertyName("replacementInitValue")>]
              ReplacementInitValue: string }

        and TableNameReplacement =
            { [<JsonPropertyName("name")>]
              Name: string
              [<JsonPropertyName("replacementName")>]
              ReplacementName: string }

    module Records =

        open Freql.Core.Utils.Extensions

        type RecordField =
            { Name: string
              Type: string
              Initialization: string }

        type Record =
            { Name: string
              Fields: RecordField list
              IncludeBlank: bool
              AdditionMethods: string list
              DocumentCommentLines: string list }

        let create (profile: Configuration.GeneratorProfile) (record: Record) =
            let fields =
                record.Fields
                |> List.mapi (fun i rf ->
                    let name =
                        rf.Name
                        |> fun n -> n.ToPascalCase()
                        |> fun n ->
                            match profile.IncludeJsonAttributes with
                            | true -> $"[<JsonPropertyName(\"{n.ToCamelCase()}\")>] {n}"
                            | false -> n
                        |> fun n -> $"{n}: {rf.Type}"

                    match i with
                    | 0 when record.Fields.Length = 1 -> $"    {{ {name} }}"
                    | 0 -> $"    {{ {name}"
                    | _ when i = record.Fields.Length - 1 -> $"      {name} }}"
                    | _ -> $"      {name}")

            let blank =
                record.Fields
                |> List.mapi (fun i rf ->
                    let name = rf.Name |> fun n -> n.ToPascalCase()

                    let content = $"{name} = {rf.Initialization}"

                    match i with
                    | 0 when record.Fields.Length = 1 -> $"        {{ {content} }}"
                    | 0 -> $"        {{ {content}"
                    | _ when i = record.Fields.Length - 1 -> $"          {content} }}"
                    | _ -> $"          {content}")
                |> fun r -> [ "    static member Blank() =" ] @ r

            match fields.Length with
            | 0 -> []
            //| 1 -> [ $"type {table.Name.ToPascalCase()} = {fields.[0].Trim()} }}" ]
            | _ ->
                [ yield! record.DocumentCommentLines
                  $"type {record.Name.ToPascalCase()} ="
                  yield! fields
                  ""
                  yield! blank
                  match record.AdditionMethods.IsEmpty |> not with
                  | true ->
                      ""
                      yield! record.AdditionMethods
                  | false -> () ]

    module Functions =

        let create = ()

    open System.Text.RegularExpressions
    open Freql.Core.Utils

    [<RequireQualifiedAccess>]
    type MatchType =
        | Regex of string
        | String of string

        member mt.Test(value: string) =
            match mt with
            | Regex pattern -> Regex.IsMatch(value, pattern)
            | String str -> String.Equals(value, str, StringComparison.Ordinal)

    type TypeReplacement =
        { Match: MatchType
          ReplacementType: string
          Initialization: string option }

        static member Create(config: Configuration.TypeReplacementConfiguration) =
            { Match =
                match config.MatchType with
                | "regex" -> MatchType.Regex config.MatchValue
                | _ -> MatchType.String config.MatchValue
              ReplacementType = config.ReplacementValue
              Initialization = Some config.ReplacementInitValue }

        member tr.Attempt(name: string, typeString: string) =
            match tr.Match.Test name with
            | true -> tr.ReplacementType
            | false -> typeString

        member tr.AttemptInitReplacement(name: string, initValue: string) =
            match tr.Initialization, tr.Match.Test name with
            | Some init, true -> init
            | _ -> initValue

    type GeneratorSettings<'TTable, 'TColumn> =
        {
            Imports: string list
            IncludeJsonAttributes: bool
            TypeReplacements: TypeReplacement list
            TypeHandler: TypeReplacement list -> 'TColumn -> string
            TypeInitHandler: TypeReplacement list -> 'TColumn -> string
            NameHandler: 'TColumn -> string
            InsertColumnFilter: 'TColumn -> bool
            ContextTypeName: string
            /// <summary>
            /// A handler to generate database engine specific code that will appear at the top of output file.
            /// This is useful for generating utility functions etc. that could be used in other modules,
            /// such as in BespokeMethodsHandlers and additional methods.
            /// </summary>
            BespokeTopSectionHandler: GeneratorContext<'TTable, 'TColumn> -> string list option
            /// <summary>
            /// A handler to generate database engine specific code that will appear at the bottom of output file.
            /// This is useful for generating helper and extension functions based on the generated code.
            /// </summary>
            BespokeBottomSectionHandler: GeneratorContext<'TTable, 'TColumn> -> string list option
        }
        
    and GeneratorContext<'TTable, 'TColumn> = { Profile: Configuration.GeneratorProfile; Tables: TableDetails<'TTable, 'TColumn> list }

    and TableDetails<'TTable, 'TColumn> =
        { OriginalName: string
          ReplacementName: string option
          Sql: string
          Table: 'TTable
          Columns: 'TColumn list
          BespokeMethodsHandler: TableGeneratorContext -> string list option }

    and TableGeneratorContext = { Name: string }

    let createRecord<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (table: TableDetails<'TTable, 'TColumn>)
        =

        let fields =
            table.Columns
            |> List.map (fun cd ->
                ({ Name = settings.NameHandler cd |> fun n -> n.ToPascalCase()
                   Type = settings.TypeHandler settings.TypeReplacements cd
                   Initialization = settings.TypeInitHandler settings.TypeReplacements cd }
                : Records.RecordField))

        let createSql =
            [ "    static member CreateTableSql() = \"\"\""
              $"    {table.Sql}"
              "    \"\"\"" ]

        let selectFields =
            table.Columns
            |> List.map (fun cd -> $"          {table.OriginalName}.`{settings.NameHandler cd}`")
            |> String.concat $",{Environment.NewLine}    "

        let selectSql =
            [ "    static member SelectSql() = \"\"\""
              $"    SELECT"
              $"{selectFields}"
              $"    FROM {table.OriginalName}"
              "    \"\"\"" ]

        let tableName = $"    static member TableName() = \"{table.OriginalName}\""

        let name =
            table.ReplacementName
            |> Option.defaultValue table.OriginalName
            |> fun n -> n.ToPascalCase()
            
        let tgc = ({ Name = name }: TableGeneratorContext)

        ({ Name = name
           Fields = fields
           IncludeBlank = true
           AdditionMethods =
             [ yield! createSql
               ""
               yield! selectSql
               ""
               tableName
               match table.BespokeMethodsHandler tgc with
               | Some lines ->
                   ""

                   yield!
                       lines
                       |> List.map (fun l -> if String.IsNullOrWhiteSpace l |> not then $"    {l}" else l)
               | None -> () ]
           DocumentCommentLines =
             [ "/// <summary>"
               $"/// A record representing a row in the table `{table.OriginalName}`."
               "/// </summary>"
               "/// <remarks>"
               $"/// This record was generated via Freql.Tools on {DateTime.UtcNow}"
               "/// </remarks>" ] }
        : Records.Record)
        |> Records.create profile

    let indent value (text: string) = $"{String(' ', value * 4)}{text}"

    let indent1 text = indent 1 text

    let createBoilerPlate<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (tables: TableDetails<'TTable, 'TColumn> list)
        =
        [ yield! Header.lines
          ""
          $"namespace {profile.Namespace}"
          ""
          "open System"
          if settings.IncludeJsonAttributes then
              "open System.Text.Json.Serialization"
          yield! settings.Imports |> List.map (fun i -> $"open {i}")
          "" ]

    let createBespokeTopSection<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (tables: TableDetails<'TTable, 'TColumn> list)
        =
        [ match settings.BespokeTopSectionHandler { Profile = profile; Tables = tables } with
          | Some ls ->
              yield! ls
              ""
          | None -> () ]

    let createRecords<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (tables: TableDetails<'TTable, 'TColumn> list)
        =

        // Create the core record.
        let records =
            tables
            |> List.map (fun t -> createRecord profile settings t @ [ "" ])
            |> List.concat
            |> List.map indent1

        [ "/// <summary>"
          $"/// Records representing database bindings for `{profile.Name}`."
          "/// </summary>"
          "/// <remarks>"
          $"/// Module generated on {DateTime.UtcNow} (utc) via Freql.Tools."
          "/// </remarks>"
          $"[<RequireQualifiedAccess>]"
          $"module Records =" ]
        @ records


    // Generate records/code for insert etc.
    //
    // Need -
    // Configuration change
    // * Property for skip fields (i.e. id which could be auto increment and not needed on inserts)
    //  "operations": [
    //      {
    //          "name": "test",
    //          "tableFilter": "",
    //          "init":
    //      }
    //  ]
    //
    // Example:
    // let insertFoo (parameters: AddFooParameters) (context: MySqlContext) =
    //     context.insert(Records.FooRecord.TableName(), parameters)

    let generateAddParameters<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (table: TableDetails<'TTable, 'TColumn>)
        =
        let name =
            table.ReplacementName
            |> Option.defaultValue table.OriginalName
            |> fun n -> n.ToPascalCase()

        //let parametersRecords =
        table.Columns
        |> List.filter settings.InsertColumnFilter
        |> List.map (fun cd ->
            ({ Name = settings.NameHandler cd |> fun n -> n.ToPascalCase()
               Type = settings.TypeHandler settings.TypeReplacements cd
               Initialization = settings.TypeInitHandler settings.TypeReplacements cd }
            : Records.RecordField))
        |> fun f ->
            ({ Name = $"New{name}"
               Fields = f
               IncludeBlank = true
               AdditionMethods = []
               DocumentCommentLines =
                 [ "/// <summary>"
                   $"/// A record representing a new row in the table `{table.OriginalName}`."
                   "/// </summary>"
                   "/// <remarks>"
                   $"/// This record was generated via Freql.Tools on {DateTime.UtcNow}"
                   "/// </remarks>" ] }
            : Records.Record)
        |> Records.create profile


    let generateInsertOperation<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (table: TableDetails<'TTable, 'TColumn>)
        =

        let name =
            table.ReplacementName
            |> Option.defaultValue table.OriginalName
            |> fun n -> n.ToPascalCase()

        [ $"let insert{name} (context: {settings.ContextTypeName}) (parameters: Parameters.New{name}) ="
          $"    context.Insert(\"{table.OriginalName}\", parameters)" ]

    let generateSelectOperation<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (table: TableDetails<'TTable, 'TColumn>)
        =

        let name =
            table.ReplacementName
            |> Option.defaultValue table.OriginalName
            |> fun n -> n.ToPascalCase()

        [ "/// <summary>"
          $"/// Select a `Records.{name}` from the table `{table.OriginalName}`."
          $"/// Internally this calls `context.SelectSingleAnon&lt;Records.{name}&gt;` and uses Records.{name}.SelectSql()."
          $"/// The caller can provide extra string lines to create a query and boxed parameters."
          $"/// It is up to the caller to verify the sql and parameters are correct,"
          "/// this should be considered an internal function (not exposed in public APIs)."
          "/// Parameters are assigned names based on their order in 0 indexed array. For example: @0,@1,@2..."
          "/// </summary>"
          "/// <remarks>"
          $"/// This function was generated via Freql.Tools on {DateTime.UtcNow}"
          "/// </remarks>"
          "/// <example>"
          "/// <code>"
          $"/// let result = select{name}Record ctx \"WHERE `field` = @0\" [ box `value` ]"
          "/// </code>"
          "/// </example>"
          $"let select{name}Record (context: {settings.ContextTypeName}) (query: string list) (parameters: obj list) ="
          $"    let sql = [ Records.{name}.SelectSql() ] @ query |> buildSql"
          $"    context.SelectSingleAnon<Records.{name}>(sql, parameters)"
          ""
          "/// <summary>"
          $"/// Internally this calls `context.SelectAnon&lt;Records.{name}&gt;` and uses Records.{name}.SelectSql()."
          $"/// The caller can provide extra string lines to create a query and boxed parameters."
          $"/// It is up to the caller to verify the sql and parameters are correct,"
          "/// this should be considered an internal function (not exposed in public APIs)."
          "/// Parameters are assigned names based on their order in 0 indexed array. For example: @0,@1,@2..."
          "/// </summary>"
          "/// <remarks>"
          $"/// This function was generated via Freql.Tools on {DateTime.UtcNow}"
          "/// </remarks>"
          "/// <example>"
          "/// <code>"
          $"/// let result = select{name}Records ctx \"WHERE `field` = @0\" [ box `value` ]"
          "/// </code>"
          "/// </example>"
          $"let select{name}Records (context: {settings.ContextTypeName}) (query: string list) (parameters: obj list) ="
          $"    let sql = [ Records.{name}.SelectSql() ] @ query |> buildSql"
          $"    context.SelectAnon<Records.{name}>(sql, parameters)" ]

    let createParameters<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (tables: TableDetails<'TTable, 'TColumn> list)
        =

        // Create the core record.
        let records =
            tables
            |> List.map (fun t -> generateAddParameters profile settings t @ [ "" ])
            |> List.concat
            |> List.map indent1

        [ $"/// Module generated on {DateTime.UtcNow} (utc) via Freql.Tools."
          "[<RequireQualifiedAccess>]"
          "module Parameters =" ]
        @ records

    let createOperations<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (tables: TableDetails<'TTable, 'TColumn> list)
        =

        let buildSql =
            "let buildSql (lines: string list) = lines |> String.concat Environment.NewLine"

        // Create the core record.
        let ops =
            tables
            |> List.map (fun t ->
                [ yield! generateSelectOperation profile settings t
                  ""
                  yield! generateInsertOperation profile settings t
                  "" ])
            //
            |> List.concat
            |> List.map indent1

        [ $"/// Module generated on {DateTime.UtcNow} (utc) via Freql.Tools."
          "[<RequireQualifiedAccess>]"
          $"module Operations ="
          ""
          indent1 buildSql
          "" ]
        @ ops

    let createBespokeBottomSection<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (tables: TableDetails<'TTable, 'TColumn> list)
        =
        [ match settings.BespokeBottomSectionHandler { Profile = profile; Tables = tables } with
          | Some ls ->
              yield! ls
              ""
          | None -> () ]

    let generateCode<'TTable, 'TColumn>
        (profile: Configuration.GeneratorProfile)
        (settings: GeneratorSettings<'TTable, 'TColumn>)
        (tables: TableDetails<'TTable, 'TColumn> list)
        =

        [ createBoilerPlate profile settings tables
          createBespokeTopSection profile settings tables
          createRecords profile settings tables
          createParameters profile settings tables
          createOperations profile settings tables
          createBespokeBottomSection profile settings tables ]
        |> List.concat
        |> String.concat Environment.NewLine
